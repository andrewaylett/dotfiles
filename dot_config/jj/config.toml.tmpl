[user]
name = "Andrew Aylett"
email = "{{ .email }}"

[ui]
default-command = "log"
#merge-editor = "idea"
#diff-editor = ["idea", "merge", "$left", "$right", "$output", "--wait"]
log-word-wrap = true

#[merge-tools.idea]
#merge-args = ["-na", "/Users/andrewaylett/Applications/IntelliJ IDEA Ultimate.app/Contents/MacOS/idea", "-W", "--args", "merge", "$left", "$right", "$base", "$output"]
#program = "open"

[git]
write-change-id-header = true
colocate = true

[revset-aliases]
'archive_refs()' = 'bookmarks(glob:"archive/*")'
'working_refs()' = 'present(@) | present(trunk()) | (bookmarks() ~ archive_refs())'
'archive()' = '::archive_refs() ~ ::((~::archive_refs()) | working_refs())'
#'archive()' = '::archive_refs() ~ ::((visible_heads() | bookmarks() | trunk()) ~ archive_refs())'
'live_heads()' = 'heads(mutable() ~ archive())'
'live_fork_point()' = 'fork_point(live_heads())'
'working_heads()' = 'live_heads() | present(@) | present(trunk()) | git_head() | working_copies()'
'working_fork_point()' = 'fork_point(working_heads())'
'working_set()' = 'connected(working_fork_point() | working_heads())'

'branch_heads()' = 'working_refs() | remote_bookmarks() | git_head() | working_copies()'
'branch_fork_point()' = 'fork_point(branch_heads())'
'branch_set()' = 'connected(branch_heads() | branch_fork_point())'

[revsets]
'log' = 'ancestors(working_set(), 2)'
#'log' = 'present(@) | ancestors((live_heads().. | working_set()), 2) | present(trunk())'

[aliases]
with-git = ["util", "exec", "--", "bash", "-c", """
set -euo pipefail
export GIT_DIR=$(jj git root)
exec "$0" "$@"
"""]
pre-commit = ["util", "exec", "--", "bash", "-c", """
set -euo pipefail

REPO_ROOT="$(dirname $(jj config path --user))"
PASSED_FILE="$REPO_ROOT/pre-commit-passes"

touch "$PASSED_FILE"

export GIT_DIR=$(jj git root)
TREE=$(git rev-parse HEAD^{tree})

if grep -Fxq "$TREE" "$PASSED_FILE"; then
  echo "pre-commit already passed for tree $TREE, skipping."
  exit 0
fi

EMPTY=$(jj log --no-graph -r @ -T 'empty')
if [ "$EMPTY" = "false" ]; then
  jj new
fi

FROM=$(jj log --no-graph -r "fork_point(trunk() | @)" -T "commit_id")
TO=$(jj log --no-graph -r "@-" -T "commit_id")

if grep -Fxq "$TO" "$PASSED_FILE"; then
  echo "pre-commit already passed for $TO, skipping."
  exit 0
fi

if uvx --with 'pre-commit-uv' pre-commit run --from="$FROM" --to="$TO" "$@"; then
  echo "$TO" >> "$PASSED_FILE"
  echo "$TREE" >> "$PASSED_FILE"
else
  echo "pre-commit failed for $TO"
  exit 1
fi
""", ""]

pre-commit-branch = ["util", "exec", "--", "bash", "-c", """
set -euo pipefail

REPO_ROOT="$(dirname $(jj config path --user))"
PASSED_FILE="$REPO_ROOT/pre-commit-passes"

touch "$PASSED_FILE"

for change in $(jj log -r "(::@ & mutable()):: ~ empty()" --no-graph -T 'change_id ++ "\n"' --reversed)
do
  TO=$(jj log --no-graph -r "$change" -T "commit_id")
  TREE=$(git rev-parse $TO^{tree})

  if grep -Fxq "$TO" "$PASSED_FILE"; then
    echo "pre-commit already passed for $change, skipping."
  elif grep -Fxq "$TREE" "$PASSED_FILE"; then
    echo "pre-commit already passed for the tree in $change, skipping."
  else
    jj new "$change"
    [ "$(jj log --no-graph -r @ -T conflict)" = "false" ] || break
    jj pre-commit
  fi
done
""", ""]

rebase-trunk = ["rebase", "-b", "@", "-d", "trunk()"]
rebase-all-trunk = ["rebase", "-b", "all:(visible_heads() ~ immutable_heads()) & working_set()", "-d", "trunk()"]
sq = ["squash"]
log-all = ["log", "-r", "::"]
log-branches = ["log", "-r", "branch_set()"]

[template-aliases]
'micro_commit_info(c)' = '''
concat(
  if(c.immutable(), label("immutable", "◆")),
  coalesce(
    if(c.empty() && !c.immutable(), label("empty", "empty")),
    c.change_id().shortest()
  ),
  if(c.conflict(), label("conflict", "×")),
  coalesce(
    if(c.contained_in("trunk()"), label("git_head", "―")),
    if(c.contained_in("trunk()::"), label("git_head", "↑")),
    "↓"
  )
)
'''

commit_and_parents_info = '''
separate(
  ", ",
  micro_commit_info(self),
  parents.map(|c| micro_commit_info(c)).join("+")
)
'''

[fsmonitor]
backend = "watchman"

[fsmonitor.watchman]
register-snapshot-trigger = true

[snapshot]
auto-track = '~glob:"*~" & ~glob:".*.swp" & ~glob:"node_modules" & ~glob:".DS_Store" & ~glob:"mise.*.local.toml" & ~glob:"mise.local.toml"'
